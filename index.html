<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>15 Puzzle Solver - Branch and Bound</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    #puzzle {
      display: grid;
      grid-template-columns: repeat(4, 80px);
      grid-template-rows: repeat(4, 80px);
      gap: 5px;
      margin-bottom: 20px;
    }
    .tile {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #ccc;
      font-size: 24px;
      font-weight: bold;
      cursor: default;
    }
    .empty {
      background-color: #fff;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>15 Puzzle Solver - Branch and Bound</h1>
  <div id="puzzle"></div>
  <button onclick="randomizePuzzle()">Randomize</button>
  <button onclick="solvePuzzle()">Solve</button>

  <script>
    const puzzle = document.getElementById("puzzle");
    let tiles = [];

    function createPuzzle(state) {
      puzzle.innerHTML = "";
      state.forEach((val, i) => {
        const tile = document.createElement("div");
        tile.className = "tile" + (val === 0 ? " empty" : "");
        tile.textContent = val === 0 ? "" : val;
        puzzle.appendChild(tile);
      });
    }

    function getRandomPuzzle() {
      const array = [...Array(16).keys()];
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function randomizePuzzle() {
      tiles = getRandomPuzzle();
      createPuzzle(tiles);
    }

    function solvePuzzle() {
      const solution = branchAndBound(tiles);
      if (!solution) return alert("No solution found!");

      let i = 0;
      const interval = setInterval(() => {
        createPuzzle(solution[i]);
        i++;
        if (i >= solution.length) clearInterval(interval);
      }, 500);
    }

    function isGoal(state) {
      for (let i = 0; i < 15; i++) {
        if (state[i] !== i + 1) return false;
      }
      return state[15] === 0;
    }

    function manhattanDistance(state) {
      let dist = 0;
      for (let i = 0; i < 16; i++) {
        if (state[i] !== 0) {
          const goalRow = Math.floor((state[i] - 1) / 4);
          const goalCol = (state[i] - 1) % 4;
          const currRow = Math.floor(i / 4);
          const currCol = i % 4;
          dist += Math.abs(goalRow - currRow) + Math.abs(goalCol - currCol);
        }
      }
      return dist;
    }

    function branchAndBound(start) {
      const PriorityQueue = class {
        constructor() {
          this.data = [];
        }
        enqueue(item, priority) {
          this.data.push({ item, priority });
          this.data.sort((a, b) => a.priority - b.priority);
        }
        dequeue() {
          return this.data.shift().item;
        }
        isEmpty() {
          return this.data.length === 0;
        }
      };

      const visited = new Set();
      const queue = new PriorityQueue();
      queue.enqueue([start, [], 0], manhattanDistance(start));

      const dirs = [
        [-1, 0], [1, 0], [0, -1], [0, 1]
      ];

      while (!queue.isEmpty()) {
        const [curr, path, cost] = queue.dequeue();
        const key = curr.join(",");
        if (visited.has(key)) continue;
        visited.add(key);

        if (isGoal(curr)) return [...path, curr];

        const zeroIdx = curr.indexOf(0);
        const r = Math.floor(zeroIdx / 4);
        const c = zeroIdx % 4;

        for (const [dr, dc] of dirs) {
          const nr = r + dr;
          const nc = c + dc;
          if (nr >= 0 && nr < 4 && nc >= 0 && nc < 4) {
            const ni = nr * 4 + nc;
            const newState = curr.slice();
            [newState[zeroIdx], newState[ni]] = [newState[ni], newState[zeroIdx]];
            const newCost = cost + 1;
            const priority = newCost + manhattanDistance(newState);
            queue.enqueue([newState, [...path, curr], newCost], priority);
          }
        }
      }
      return null;
    }

    randomizePuzzle();
  </script>
</body>
</html>
