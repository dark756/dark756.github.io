<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>15 Puzzle Solver - Branch and Bound</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    #puzzle {
      display: grid;
      grid-template-columns: repeat(4, 80px);
      grid-template-rows: repeat(4, 80px);
      gap: 5px;
      margin-bottom: 20px;
    }
    .tile {
      width: 80px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #ccc;
      font-size: 24px;
      font-weight: bold;
      cursor: default;
    }
    .empty {
      background-color: #fff;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>15 Puzzle Solver - Branch and Bound</h1>
  <div id="puzzle"></div>
  <button onclick="randomizePuzzle()">Randomize</button>
  <button onclick="solvePuzzle()">Solve</button>

  <script>
    const puzzle = document.getElementById("puzzle");
    let tiles = [];

    function createPuzzle(state) {
      puzzle.innerHTML = "";
      state.forEach((val) => {
        const tile = document.createElement("div");
        tile.className = "tile" + (val === 0 ? " empty" : "");
        tile.textContent = val === 0 ? "" : val;
        puzzle.appendChild(tile);
      });
    }

    function getRandomPuzzle() {
      const array = [...Array(16).keys()];
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function isSolvable(puzzle) {
      let invCount = 0;
      for (let i = 0; i < 15; i++) {
        for (let j = i + 1; j < 16; j++) {
          if (puzzle[i] && puzzle[j] && puzzle[i] > puzzle[j]) invCount++;
        }
      }
      const rowFromBottom = 3 - Math.floor(puzzle.indexOf(0) / 4);
      return (invCount + rowFromBottom) % 2 === 0;
    }

    function randomizePuzzle() {
      do {
        tiles = getRandomPuzzle();
      } while (!isSolvable(tiles));
      createPuzzle(tiles);
    }

    function solvePuzzle() {
      if (!isSolvable(tiles)) {
        alert("Puzzle is not solvable!");
        return;
      }
      const solution = branchAndBound(tiles);
      if (!solution) {
        alert("No solution found!");
        return;
      }

      let i = 0;
      const interval = setInterval(() => {
        createPuzzle(solution[i]);
        i++;
        if (i >= solution.length) clearInterval(interval);
      }, 500);
    }

    function isGoal(state) {
      for (let i = 0; i < 15; i++) {
        if (state[i] !== i + 1) return false;
      }
      return state[15] === 0;
    }

    function manhattanDistance(state) {
      let dist = 0;
      for (let i = 0; i < 16; i++) {
        if (state[i] !== 0) {
          const goalRow = Math.floor((state[i] - 1) / 4);
          const goalCol = (state[i] - 1) % 4;
          const currRow = Math.floor(i / 4);
          const currCol = i % 4;
          dist += Math.abs(goalRow - currRow) + Math.abs(goalCol - currCol);
        }
      }
      return dist;
    }

    function branchAndBound(start) {
  const MAX_DEPTH = 50; // limit search depth

  class PriorityQueue {
    constructor() {
      this.data = [];
    }
    enqueue(item, priority) {
      this.data.push({ item, priority });
      this.data.sort((a, b) => a.priority - b.priority);
    }
    dequeue() {
      return this.data.shift().item;
    }
    isEmpty() {
      return this.data.length === 0;
    }
  }

  const visited = new Set();
  const queue = new PriorityQueue();
  queue.enqueue([start, [], 0], manhattanDistance(start));

  const dirs = [
    [-1, 0], [1, 0], [0, -1], [0, 1]
  ];

  while (!queue.isEmpty()) {
    const [curr, path, cost] = queue.dequeue();
    const key = curr.join(",");
    if (visited.has(key)) continue;
    visited.add(key);

    if (isGoal(curr)) return [...path, curr];

    if (cost >= MAX_DEPTH) continue; // depth limit added

    const zeroIdx = curr.indexOf(0);
    const r = Math.floor(zeroIdx / 4);
    const c = zeroIdx % 4;

    for (const [dr, dc] of dirs) {
      const nr = r + dr;
      const nc = c + dc;
      if (nr >= 0 && nr < 4 && nc >= 0 && nc < 4) {
        const ni = nr * 4 + nc;
        const newState = curr.slice();
        [newState[zeroIdx], newState[ni]] = [newState[ni], newState[zeroIdx]];
        const newCost = cost + 1;
        const priority = newCost + manhattanDistance(newState);
        queue.enqueue([newState, [...path, curr], newCost], priority);
      }
    }
  }

  return null;
}


    randomizePuzzle();
  </script>
</body>
</html>
